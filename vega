#!/usr/bin/env bb

(ns vega
  (:require [clojure.java.io :as io]
            [clojure.tools.cli :as cli]
            [cheshire.core :as json]
            [hiccup2.core :as hiccup]
            [org.httpkit.server :as server]
            serve
            watcher))

(defn static-js [filename]
  {:status 200
   :headers {"Content-Type" "application/javascript"}
   :body (slurp (io/file (.getParent (io/file *file*)) "static" filename))})

(defn index [provider {:keys [uri]} {:keys [json thread-first thread-last]}]
  (condp = uri
    "/static/vega.js" (static-js "vega.js")
    "/static/vega-lite.js" (static-js "vega-lite.js")
    "/static/vega-embed.js" (static-js "vega-embed.js")
    "/data.json" {:status 200
                  :headers {"Content-Type" "application/json"}
                  :body (eval `(-> (slurp ~json)
                                   json/parse-string
                                   ~thread-first
                                   (->> ~thread-last)
                                   json/generate-string))}
    "/" {:status 200
         :body (str
                 (hiccup/html
                   [:html
                    [:head
                     [:meta {:charset "UTF-8"}]
                     [:meta {:name "viewport" :content "width=device-width, initial-scale=1"}]
                     [:title "Vega"]
                     [:link {:rel "icon" :href "data:,"}]
                     [:link {:rel "apple-touch-icon" :href "data:,"}]
                     [:script {:src "/static/vega.js"}]
                     [:script {:src "/static/vega-lite.js"}]
                     [:script {:src "/static/vega-embed.js"}]]
                    [:body
                     [:div#viz]
                     [:script {:type "application/javascript"}
                      (hiccup/raw (serve/listen-and "console.log('Evaling'); vegaEmbed('#viz', JSON.parse(event.data))"))]
                     [:script {:type "application/javascript"}
                      (hiccup/raw (format "vegaEmbed('#viz', %s);" (provider)))]]]))}
    {:status 404}))

(defn eval-safe [form]
  (try
    (eval form)
    (catch Exception e
      (prn "Error during eval:" (.getMessage e))
      nil)))

(defn serve-file [path port {:keys [json] :as opts}]
  (let [url (str "http://localhost:" port "/")
        channels (atom #{})
        watch (watcher/file)
        provider #(-> (slurp path)
                      (->> (format "(do %s)"))
                      read-string
                      eval-safe
                      (json/generate-string {:pretty true}))
        callback (fn []
                   (println "Changes detected")
                   (let [data (provider)]
                     (doseq [ch @channels]
                       (server/send! ch data))))]
    (serve/serve-channels #(index provider % opts) port channels)
    (println "Serving at" url)
    (watch (.getAbsolutePath (io/file path)) callback)
    (when json (watch (.getAbsolutePath (io/file json)) callback))))

(defn serve-stdin [port opts]
  (let [url (str "http://localhost:" port "/")
        provider (constantly (json/generate-string (read-string (slurp *in*)) {:pretty true}))]
    (println "Serving at" url)
    (serve/serve #(index provider % opts) port)
    @(promise)))

(def cli-opts
  [["-j" "--json FILE" "file with JSON data to load"]
   ["-p" "--port PORT" "port to serve on"
    :default 8888
    :parse-fn #(Integer/parseInt %)]
   ["-t" "--thread-last FORM" "Clojure form to transform data with using thread last (->>)"
    :default 'identity
    :parse-fn read-string]
   ["-T" "--thread-first FORM" "Clojure form to transform data with using thread first (->)"
    :default 'identity
    :parse-fn read-string]])

(let [{{:keys [port] :as opts} :options [path] :arguments} (cli/parse-opts *command-line-args* cli-opts)]
  (if (= path "-")
    (serve-stdin port opts)
    (serve-file path port opts)))
